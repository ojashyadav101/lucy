# Skill Management Design

This document explains how skill files in `/work/skills` are managed during SDK regeneration.

## Intent

- Skills are persistent memory for future agent runs.
- Repo-managed skills should update reliably when backend code changes.
- Agent/user-created skills and helper scripts should not be deleted by unrelated regenerations.

## Two Categories of Skill Files

1. **Managed files**
   - Generated from repo skills (`backend/coworker/skills/**`) during SDK regeneration.
   - Includes SKILL.md, scripts, references, assets that are part of repo-managed skills.

2. **Custom files**
   - Created by agents/users directly in `/work/skills/**`.
   - Examples: new skill folders, integration helper scripts, ad-hoc references.

## Regeneration Behavior

SDK regeneration runs smart skill sync with a per-volume manifest:

- Manifest path: `/work/.sdk_managed_skills_manifest_v1.json`
- Manifest contains the file list that SDK sync last managed.

Sync algorithm:

1. Build `new_managed_files` from current repo-managed skills.
2. Read `old_managed_files` from the manifest.
3. Preserve SKILL.md custom tail content (after END marker), including legacy path aliases.
4. Delete only stale files in `(old_managed_files - new_managed_files)`.
5. Write/update all `new_managed_files`.
6. Save manifest = `new_managed_files`.

Result:

- Unknown/custom files are preserved.
- Only previously-managed files are pruned when no longer managed.

## Conservative Migration Rule

If the manifest does not exist yet:

- Do **not** broad-delete files under `/work/skills`.
- Write/update managed files.
- Create the manifest for future runs.

This avoids accidental deletion of historical custom content on first run.

## Practical Guidance for Agents

- It is safe to create reusable helper scripts under skill folders in `/work/skills`.
- Continue documenting helper scripts in SKILL.md so future runs can discover and use them.
- Keep SKILL.md guidance accurate and include exact invocation commands.

## Important Caveat

If a custom file later collides with a repo-managed path, the managed write wins at that path.
Avoid naming custom files the same as expected autogenerated managed files.

