---
description: Slack interface standards for handlers, Block Kit, and messaging
globs: ["src/lucy/slack/**/*.py"]
alwaysApply: false
---

# Slack Interface Standards

## Core Principle
- Slack is Lucy's only voice. All communication with humans flows through Slack.
- Lucy should be proactive — don't wait to be asked when you have useful information.

## Workspace Resolution
- Every event handler MUST resolve `workspace_id` from the Slack event payload.
- Use `slack/middleware.py` for consistent workspace extraction and user lookup.
- If workspace resolution fails, respond with a user-friendly error and log the raw event.

## Message Composition
- All user-facing messages go through `slack/blocks.py` composer functions.
- Never construct Block Kit JSON inline in handler code.
- Block Kit actions MUST be prefixed with `lucy_action_` namespace.

## Thread Awareness
- If the triggering message is in a thread, always reply in that thread (`thread_ts`).
- If the triggering message is top-level, reply as a new thread on that message.
- Never post a top-level channel message in response to a thread message.

## Proactive Messaging
- Cron-driven messages (heartbeat, issue alerts, workflow suggestions) are posted to relevant channels.
- Destructive or high-impact actions require approval via an interactive message before execution.
- Always use `chat_postMessage` for progress and status updates. NEVER use `chat.update` to edit existing messages. Lucy never edits her own messages — this maintains trust and gives users a visible thread of work.

## Rate Limiting
- Respect Slack's rate limits: 1 message per second per channel.
- For batch operations, queue messages with 1-second spacing.

## Error Responses
- On internal errors, post a brief apologetic message to the user thread.
- Never expose stack traces, model names, or internal error details.
